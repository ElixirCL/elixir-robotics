<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Componentes Electrónicos :: Electrónica, Robótica e IOT con Elixir</title>
    <link rel="canonical" href="https://elixircl.github.io/elixir-robotics/atomvm/components.html">
    <link rel="prev" href="devenv.html">
    <link rel="next" href="remote.html">
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../_/css/site.css">
    <link rel="stylesheet" href="../_/js/vendor/styles/monokai.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://elixircl.github.io/elixir-robotics">Electrónica, Robótica e IOT con Elixir</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Buscar en documentos">
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <!--
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
    -->
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ROOT" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Electrónica, Robótica e IOT con Elixir</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Fundamentos e Historia</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/history.html">Historia de la Robótica y Automatización</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/introduction.html">Introducción a la Electrónica</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/electricity.html">Fundamentos de Electricidad</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/components.html">Componentes Electrónicos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/programming.html">Lenguajes de Programación</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">IC y Controladores</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/ic555.html">IC555</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/pic16f877a.html">PIC16F877a</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/basicstamp.html">Parallax Basic Stamp</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/arduino.html">Arduino</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/raspberry.html">Raspberry Pi</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/esp32.html">ESP32</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/stm32.html">STM32</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/jetson.html">Nvidia Jetson &amp; AMD Kria</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/fpga.html">FPGA</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Protocolos de Comunicación</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../communication/iot.html">IOT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Herramientas</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/platformio.html">PlatformIO IDE</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/home-assistant.html">Home Assistant</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/grafana.html">Grafana</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/dashboards.html">Dashboards</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/cad.html">Herramientas de Computer Asisted Design (CAD)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/stores.html">Tiendas</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">AtomVM</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="atomvm.html">AtomVM</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="popcorn.html">Elixir PopCorn</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="devenv.html">Entorno de Desarrollo</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="components.html">Componentes Electrónicos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="remote.html">Conexión Remota</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="colosseo.html">Coliseo Atómico</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="arcade.html">Proyecto: Videojuego Arcade</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="tagboard.html">Proyecto: Tagboard</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Hardware Avanzado</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/nerves.html">Nerves</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/circuits.html">Elixir Circuits</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/soleil.html">Soleil</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/beambots.html">Beam Bots</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/grisp.html">GRiSP</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Energía Solar</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../solar/solar.html">¿Qué es la Energía Solar?</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../solar/components.html">Componentes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Electrónica, Robótica e IOT con Elixir</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Electrónica, Robótica e IOT con Elixir</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Electrónica, Robótica e IOT con Elixir</a></li>
    <li>AtomVM</li>
    <li><a href="components.html">Componentes Electrónicos</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="file:///antora/./modules/atomvm/pages/components.adoc">Editar esta página</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contenidos" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Componentes Electrónicos</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>En esta sección se mostrará ejemplos de cómo conectar y utilizar distintos componentes
de electrónica que podrían ser utilizados en los robots del coliseo atómico.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="motor-dc"><a class="anchor" href="#motor-dc"></a>Motor DC</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El <a href="https://mcielectronics.cl/shop/product/motor-gear-dc-caja-reductora-motorreductor/">Motor DC</a> requiere de una placa <a href="https://mcielectronics.cl/shop/product/controlador-de-motores-puente-h-l298n-25508/">L298N</a> para poder ser controlado desde la ESP32.
Se recomienda una alimentación de 9V separada de la placa de desarrollo para alimentar los motores
y tengan una buena velocidad. Son ideales para las ruedas que dan movimiento al carro.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/motoresdc.jpg" alt="motoresdc">
</div>
<div class="title">Figure 1. Motores DC</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones"><a class="anchor" href="#guía-de-conexiones"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para controlar un motor DC con una ESP32 y un driver L298N, se requiere de una fuente de alimentación externa para el motor, ya que la ESP32 no puede suministrar la corriente necesaria. El L298N actúa como un "puente H" que permite a la ESP32 controlar tanto la dirección como la velocidad del motor.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p><code>ESP32 GND</code> &#8594; <code>L298N GND</code> (es importante que compartan tierra)</p>
</li>
<li>
<p><code>ESP32 GPIO26</code> &#8594; <code>L298N IN1</code></p>
</li>
<li>
<p><code>ESP32 GPIO27</code> &#8594; <code>L298N IN2</code></p>
</li>
<li>
<p><code>ESP32 GPIO25</code> &#8594; <code>L298N ENA</code> (si se va a usar PWM)</p>
</li>
<li>
<p><strong>Conexión de la Fuente de Alimentación Externa</strong>:</p>
</li>
<li>
<p><code>Fuente Externa Positivo (+) ` &#8594; `L298N V12</code></p>
</li>
<li>
<p><code>Fuente Externa Negativo (-) ` &#8594; `L298N GND</code></p>
</li>
<li>
<p><strong>Conexión del Motor DC</strong>:</p>
</li>
<li>
<p><code>Motor Terminal 1</code> &#8594; <code>L298N OUT1</code></p>
</li>
<li>
<p><code>Motor Terminal 2</code> &#8594; <code>L298N OUT2</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notas sobre el pin <code>ENA</code> y el control de velocidad (PWM):</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>El módulo L298N suele venir con un jumper de plástico preinstalado en el pin <code>ENA</code> (y <code>ENB</code>).</p>
</li>
<li>
<p>Si este jumper está puesto, el motor estará siempre habilitado a máxima potencia y no podrás controlar su velocidad mediante software.</p>
</li>
<li>
<p>Para poder controlar la velocidad del motor con la ESP32, se debe retirar el jumper del pin <code>ENA</code> y conectar un pin GPIO de la ESP32 (como <code>GPIO25</code>) a <code>ENA</code>.</p>
</li>
<li>
<p>La ESP32 enviará una señal PWM (Pulse Width Modulation) a este pin <code>ENA</code>. El PWM permite simular un voltaje variable controlando el "tiempo de encendido" de la señal, lo que a su vez controla la velocidad efectiva del motor. En AtomVM, esto se gestiona mediante el módulo <code>LEDC</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo"><a class="anchor" href="#código-de-ejemplo"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule MotorTest do
  @left_motor_pin_1 26
  @left_motor_pin_2 27

  def start() do
    :gpio.set_pin_mode(@left_motor_pin_1, :output)
    :gpio.set_pin_mode(@left_motor_pin_2, :output)

    :io.format('Setup de motor finalizado~n')

    loop()
  end

  defp loop() do
    :io.format('Moviendo hacia adelante~n')
    set_motor_direction(:forward)
    Process.sleep(3000)

    :io.format('Deteniendo motor~n')
    set_motor_direction(:stop)
    Process.sleep(2000)

    :io.format('Moviendo hacia atrás~n')
    set_motor_direction(:reverse)
    Process.sleep(3000)

    loop()
  end

  defp set_motor_direction(direction) do
    case direction do
      :forward -&gt;
        :gpio.digital_write(@left_motor_pin_1, :high)
        :gpio.digital_write(@left_motor_pin_2, :low)
      :reverse -&gt;
        :gpio.digital_write(@left_motor_pin_1, :low)
        :gpio.digital_write(@left_motor_pin_2, :high)
      :stop -&gt;
        :gpio.digital_write(@left_motor_pin_1, :low)
        :gpio.digital_write(@left_motor_pin_2, :low)
      _ -&gt;
        :io.format('Dirección de motor inválida: ~p~n', [direction])
    end
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ejemplo-de-funcionamiento"><a class="anchor" href="#ejemplo-de-funcionamiento"></a>Ejemplo de Funcionamiento</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="servomotor"><a class="anchor" href="#servomotor"></a>Servomotor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A diferencia de un motor DC, el servomotor puede ser controlado con precisión, pero son más lentos.
En este caso se utilizará un <a href="https://mcielectronics.cl/shop/product/micro-servo-motor-sg90-9g-25775/">Micro servo SG90</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/servo.png" alt="servo">
</div>
<div class="title">Figure 2. Servomotor SG90</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-2"><a class="anchor" href="#guía-de-conexiones-2"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar un servomotor SG90 a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del servomotor SG90</strong>:</p>
</li>
<li>
<p><code>Cable Rojo</code>: VCC</p>
</li>
<li>
<p><code>Cable Marrón</code>: GND</p>
</li>
<li>
<p><code>Cable Naranja</code>: Señal PWM</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p><code>VCC</code> (Servo) &#8594; <code>ESP32 3v3</code></p>
</li>
<li>
<p><code>GND</code> (Servo) &#8594; <code>ESP32 GND</code></p>
</li>
<li>
<p><code>Signal</code> (Servo) &#8594; <code>ESP32 GPIO</code> (Ej: <code>GPIO13</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-2"><a class="anchor" href="#código-de-ejemplo-2"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule ServoTest do
  @servomotor_pin 13
  @servo_pwm_channel 0 # canal LEDC a usar para el servo
  @servo_pwm_timer 0   # timer LEDC a usar para el servo

  @servo_pwm_freq 50      # servos usan 50Hz
  @servo_pwm_resolution 10 # 10 bits de resolución (0-1023)

  # valores de duty cycle para ángulos comunes del SG90
  # calculados para 10 bits de resolución (máx 1023) y 50Hz (periodo 20ms):
  # 1ms (0 grados)  -&gt; (1/20) * 1023 = ~51
  # 1.5ms (90 grados) -&gt; (1.5/20) * 1023 = ~77
  # 2ms (180 grados) -&gt; (2/20) * 1023 = ~102
  @duty_0_degrees 51
  @duty_90_degrees 77
  @duty_180_degrees 100

  def start() do
    set_up_servo()

    :io.format('Servo setup finished. Starting movement sequence...~n')

    set_servo_angle(@duty_0_degrees)
    Process.sleep(1500)

    set_servo_angle(@duty_90_degrees)
    Process.sleep(1500)

    set_servo_angle(@duty_180_degrees)
    Process.sleep(1500)

    :io.format('Movement sequence completed. Entering infinite sleep.~n')
    :timer.sleep(:infinity)
  end

  defp set_up_servo() do
    :ok =
      LEDC.timer_config(
        duty_resolution: @servo_pwm_resolution,
        freq_hz: @servo_pwm_freq,
        speed_mode: LEDC.high_speed_mode(),
        timer_num: @servo_pwm_timer
      )

    :ok =
      LEDC.channel_config(
        channel: @servo_pwm_channel,
        duty: @duty_90_degrees, # iniciar el servo en una posición central
        gpio_num: @servomotor_pin,
        speed_mode: LEDC.high_speed_mode(),
        hpoint: 0,
        timer_sel: @servo_pwm_timer
      )
  end

  defp set_servo_angle(duty_cycle_value) do
    :io.format('Setting servo duty to: ~p~n', [duty_cycle_value])
    :ok = LEDC.set_duty(LEDC.high_speed_mode(), @servo_pwm_channel, duty_cycle_value)
    :ok = LEDC.update_duty(LEDC.high_speed_mode(), @servo_pwm_channel)
  end
end</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ejemplo-de-funcionamiento-2"><a class="anchor" href="#ejemplo-de-funcionamiento-2"></a>Ejemplo de Funcionamiento</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="evitar-obstáculos"><a class="anchor" href="#evitar-obstáculos"></a>Evitar Obstáculos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El módulo de evitación de obstaulos utiliza un sensor infrarrojo para enviar una señal al detectar un obstáculo.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/obstacle.jpg" alt="obstacle">
</div>
<div class="title">Figure 3. Sensor de Obstáculos IR</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-3"><a class="anchor" href="#guía-de-conexiones-3"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar un Sensor de Obstáculos IR a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del Sensor de Obstáculos IR</strong>:</p>
</li>
<li>
<p><code>VCC</code>: Alimentación</p>
</li>
<li>
<p><code>GND</code>: Tierra</p>
</li>
<li>
<p><code>OUT</code>: Salida digital</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p><code>VCC</code> (Sensor) &#8594; Pin <code>3V3</code> de la ESP32</p>
</li>
<li>
<p><code>GND</code> (Sensor) &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
<li>
<p><code>OUT</code> (Sensor) &#8594; Pin GPIO de la ESP32 (Ej: GPIO33)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notas</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Algunos módulos tienen un potenciómetro para ajustar la distancia de detección.</p>
</li>
<li>
<p>La salida <code>OUT</code> es típicamente <code>LOW</code> cuando detecta un obstáculo y <code>HIGH</code> cuando no detecta nada.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-3"><a class="anchor" href="#código-de-ejemplo-3"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule DetectTest do
  @led_pin 2
  @detection_pin 33

  def start() do
    :gpio.set_pin_mode(@led_pin, :output)
    :gpio.set_pin_mode(@detection_pin, :input)
    loop()
  end

  defp loop() do
    level = read_detection(@detection_pin)
    :gpio.digital_write(@led_pin, level)
    Process.sleep(100)
    loop()
  end

  defp read_detection(pin) do
    result = GPIO.digital_read(pin)
    :io.format('Result = ~p~n', [result])
    result
  end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sensor-de-temperatura-y-humedad"><a class="anchor" href="#sensor-de-temperatura-y-humedad"></a>Sensor de temperatura y humedad</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El módulo de DHT11 es un sensor digital que mide la temperatura ambiente y la humedad, usando un sensor de humedad capacitativo y un termistor, mostrando los datos a través de un pin digital.</p>
</div>
<div class="paragraph">
<p>Requiere de un driver adicional: <a href="https://github.com/atomvm/atomvm_dht" class="bare">https://github.com/atomvm/atomvm_dht</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/dht.webp" alt="dht">
</div>
<div class="title">Figure 4. Sensor DHT11</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-4"><a class="anchor" href="#guía-de-conexiones-4"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar un sensor DHT11 a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del Sensor DHT</strong>:</p>
</li>
<li>
<p><code>VCC</code> (o <code>+</code>): Alimentación (3.3V)</p>
</li>
<li>
<p><code>DATA</code> (o <code>SIG</code>): Pin de datos</p>
</li>
<li>
<p><code>GND</code> (o <code>-</code>): Tierra</p>
</li>
<li>
<p><strong>(Nota: Algunos módulos DHT tienen 3 pines, otros tienen 4 y el pin no usado se deja flotante. Asegúrate de identificar <code>VCC</code>, <code>DATA</code> y <code>GND</code> correctamente).</strong></p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p><code>VCC</code> (DHT) &#8594; Pin <code>3V3</code> de la ESP32</p>
</li>
<li>
<p><code>GND</code> (DHT) &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
<li>
<p><code>DATA</code> (DHT) &#8594; Pin GPIO de la ESP32 (Ej: <code>GPIO21</code>)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-4"><a class="anchor" href="#código-de-ejemplo-4"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule DhtTest do
  @dht_pin 21

  def start() do
    {:ok, dht} = :dht.start(%{pin: @dht_pin, device: :dht_11})
    loop(dht)
  end

  defp loop(dht) do
    take_reading(dht)
    Process.sleep(5000)
    loop(dht)
  end

  defp take_reading(dht) do
    case :dht.take_reading(dht) do
      {:ok, {{temp, tempFractional}, {hum, humFractional}}} -&gt;
        :io.format('Temperature: ~p.~pC  Humidity: ~p.~p%~n', [
          temp,
          tempFractional,
          hum,
          humFractional
        ])
      error -&gt;
        :io.format('Error taking reading: ~p~n', [error])
    end
  end
end</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">mix.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">  defp deps do
    [
      {:exatomvm, git: "https://github.com/atomvm/ExAtomVM/"},
      {:dht, git: "https://github.com/UncleGrumpy/atomvm_dht"}
    ]
  end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sensor-de-movimiento"><a class="anchor" href="#sensor-de-movimiento"></a>Sensor de movimiento</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El sensor de movimiento PIR mide la luz infrarroja emitida en su campo de visión. Cada cuerpo libera energía térmica, lo que permite que el sensor los detecte.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/pir.jpg" alt="pir">
</div>
<div class="title">Figure 5. Sensor PIR</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-5"><a class="anchor" href="#guía-de-conexiones-5"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar un Sensor de Movimiento PIR a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del Sensor PIR</strong>:</p>
</li>
<li>
<p><code>VCC</code>: Alimentación</p>
</li>
<li>
<p><code>GND</code>: Tierra</p>
</li>
<li>
<p><code>OUT</code>: Salida digital (HIGH cuando detecta movimiento, LOW en reposo)</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p><code>VCC</code> (PIR) &#8594; Pin <code>3V3</code> de la ESP32</p>
</li>
<li>
<p><code>GND</code> (PIR) &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
<li>
<p><code>OUT</code> (PIR) &#8594; Pin GPIO de la ESP32 (Ej: GPIO26)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-5"><a class="anchor" href="#código-de-ejemplo-5"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule SensorTest do
  @led_pin 2
  @motion_pin 26

  def start() do
    :gpio.set_pin_mode(@led_pin, :output)
    :gpio.set_pin_mode(@motion_pin, :input)
    loop()
  end

  defp loop() do
    level = read_detection(@motion_pin)
    :gpio.digital_write(@led_pin, level)
    Process.sleep(100)
    loop()
  end

  defp read_detection(pin) do
    result = GPIO.digital_read(pin)
    :io.format('Result = ~p~n', [result])
    result
  end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fotoresistencia"><a class="anchor" href="#fotoresistencia"></a>Fotoresistencia</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La fotoresistencia son útiles para crear robots que sigan líneas
o eviten obstáculos según el nivel de luz.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/foto.jpg" alt="foto">
</div>
<div class="title">Figure 6. Módulo de Fotoresistencia</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-6"><a class="anchor" href="#guía-de-conexiones-6"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar un Módulo de Fotoresistencia a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del Módulo de Fotoresistencia</strong>:</p>
</li>
<li>
<p><code>VCC</code>: Alimentación</p>
</li>
<li>
<p><code>GND</code>: Tierra</p>
</li>
<li>
<p><code>OUT</code> (o <code>DO</code>): Salida digital</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p><code>VCC</code> &#8594; Pin <code>3V3</code> de la ESP32</p>
</li>
<li>
<p><code>GND</code> &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
<li>
<p><code>OUT</code> &#8594; Pin GPIO de la ESP32 (Ej: GPIO26)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notas</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Estos módulos suelen tener un potenciómetro para ajustar el umbral de luz que activa la salida digital.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El ejemplo utilizado para el sensor de movimento también aplica para la fotoresistencia.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="potenciometro"><a class="anchor" href="#potenciometro"></a>Potenciometro</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Los pontenciómetros son útiles para configurar la intensidad de ciertas configuraciones.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/potentiometer.jpg" alt="potentiometer">
</div>
<div class="title">Figure 7. Potenciómetro</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-7"><a class="anchor" href="#guía-de-conexiones-7"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar un Potenciómetro a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del Potenciómetro</strong>:</p>
</li>
<li>
<p>Pin Exterior 1: <code>VCC</code> (Alimentación)</p>
</li>
<li>
<p>Pin Exterior 2: <code>GND</code> (Tierra)</p>
</li>
<li>
<p>Pin Central (Wiper): <code>SIG</code> (Salida de señal analógica)</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p>Pin Exterior 1 &#8594; Pin <code>3V3</code> de la ESP32</p>
</li>
<li>
<p>Pin Exterior 2 &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
<li>
<p>Pin Central &#8594; Pin ADC de la ESP32 (Ej: <code>GPIO34</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notas</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Los pines ADC de la ESP32 son específicos. <code>GPIO32-39</code> son los más comunes para ADC1.</p>
</li>
<li>
<p>La lectura del potenciómetro proporcionará un valor analógico que varía según la posición del eje.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-6"><a class="anchor" href="#código-de-ejemplo-6"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule PotentiometerTest do
  @potentiometer_pin 34

  def start do
    :ok = :esp_adc.start(@potentiometer_pin, bitwidth: :bit_max, atten: :db_12)

    loop()
  end

  def loop() do
    read_potentiometer(@potentiometer_pin)

    loop()
  end

  defp read_potentiometer(pin) do
    {:ok, {raw, mv}} =
      :esp_adc.read(pin, [:raw, :voltage, samples: 48])

    :io.format('ADC pin ~p raw value=~p millivolts=~p~n', [pin, raw, mv])
  end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zumbador-activo-y-pasivo"><a class="anchor" href="#zumbador-activo-y-pasivo"></a>Zumbador activo y pasivo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Los zumbadores activos tienen un oscilador interno que produce un tono, lo que los hace fácil de usar. En cambio, los zumbadores pasivos requieren de una señal externa para generar un tono, ofreciendo mayor control a cambio de mayor complejidad.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/buzzer.webp" alt="buzzer">
</div>
<div class="title">Figure 8. Zumbador</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-8"><a class="anchor" href="#guía-de-conexiones-8"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar un Zumbador Activo a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del Zumbador Activo</strong>:</p>
</li>
<li>
<p>Pin Positivo (<code>+</code>): Alimentación (pin más largo)</p>
</li>
<li>
<p>Pin Negativo (<code>-</code>): Tierra (pin más corto)</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p>Pin Positivo &#8594; Pin GPIO de la ESP32 (Ej: GPIO26)</p>
</li>
<li>
<p>Pin Negativo &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notas</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Un zumbador activo produce un tono fijo cuando se le aplica voltaje. No requiere una señal PWM para generar sonido.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-7"><a class="anchor" href="#código-de-ejemplo-7"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule BuzzerTest do
  @led_pin 2
  @detection_pin 33
  @buzzer_pin 26

  def start() do
    :gpio.set_pin_mode(@led_pin, :output)
    :gpio.set_pin_mode(@detection_pin, :input)
    :gpio.set_pin_mode(@buzzer_pin, :output)
    loop()
  end

  defp loop() do
    level = read_detection(@detection_pin)
    :gpio.digital_write(@led_pin, level)
    :gpio.digital_write(@buzzer_pin, level)
    Process.sleep(100)
    loop()
  end

  defp read_detection(pin) do
    result = :gpio.digital_read(pin)
    :io.format('Result = ~pn', [result])
    result
  end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="botones"><a class="anchor" href="#botones"></a>Botones</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Un botón pulsador táctil común de 4 pines tiene sus contactos internos configurados de manera que los dos pines en cada uno de sus lados largos están siempre eléctricamente conectados entre sí. Al presionar el botón, se establece temporalmente una conexión entre estos dos lados que de otro modo estarían separados, cerrando el circuito. Esta configuración interna significa que para cablear el botón, solo necesitas usar un pin de cada lado opuesto, ya que el otro pin en el mismo lado ofrece un punto de conexión idéntico.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/button.png" alt="button">
</div>
<div class="title">Figure 9. Botón</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-9"><a class="anchor" href="#guía-de-conexiones-9"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>En el ejemplo se utiliza un pull-up interno. Para conectar un Botón Pulsador a la ESP32 con pull-up interno:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines del Botón Pulsador</strong>: Dos terminales</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p>Terminal 1 del Botón &#8594; Pin GPIO de la ESP32 (Ej: GPIO33)</p>
</li>
<li>
<p>Terminal 2 del Botón &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Notas</strong>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Con esta configuración, el pin GPIO estará <code>HIGH</code> (3.3V) cuando el botón no esté presionado (gracias al pull-up interno).</p>
</li>
<li>
<p>Cuando el botón es presionado, el pin GPIO se conecta a <code>GND</code> y su lectura será <code>LOW</code>.</p>
</li>
<li>
<p>Esto elimina la necesidad de un resistor externo.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-8"><a class="anchor" href="#código-de-ejemplo-8"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule ButtonTest do
  @test_duty 3000
  @test_fade_time 2000

  @high_speed_timer 0
  @low_speed_timer 1

  @led_1 2
  @led_2 23

  @button_pin 33

  def start do
    GPIO.set_pin_mode(@button_pin, :input)
    GPIO.set_pin_pull(@button_pin, :up)

    ledc_hs_timer = [
      {:duty_resolution, 13},
      {:freq_hz, 5000},
      {:speed_mode, LEDC.high_speed_mode()},
      {:timer_num, @high_speed_timer}
    ]

    :ok = LEDC.timer_config(ledc_hs_timer)

    ledc_ls_timer = [
      {:duty_resolution, 13},
      {:freq_hz, 5000},
      {:speed_mode, LEDC.low_speed_mode()},
      {:timer_num, @low_speed_timer}
    ]

    :ok = LEDC.timer_config(ledc_ls_timer)

    ledc_channel = [
      [
        {:channel, 0},
        {:duty, 0},
        {:gpio_num, @led_1},
        {:speed_mode, LEDC.high_speed_mode()},
        {:hpoint, 0},
        {:timer_sel, @high_speed_timer}
      ],
      [
        {:channel, 1},
        {:duty, 0},
        {:gpio_num, @led_2},
        {:speed_mode, LEDC.high_speed_mode()},
        {:hpoint, 0},
        {:timer_sel, @high_speed_timer}
      ]
    ]

    Enum.each(ledc_channel, fn channel_config -&gt; :ok = LEDC.channel_config(channel_config) end)
    :ok = LEDC.fade_func_install(0)
    loop(ledc_channel)
  end

  def loop(ledc_channel) do
    if read_button(@button_pin) == :pressed do
      wait_for_release(@button_pin)
    end

    :io.format('1. LEDC fade up to duty = p~n', [@test_duty])
    Enum.each(ledc_channel, fn channel_config -&gt; do_stage_1(channel_config) end)
    Process.sleep(@test_fade_time)

    :io.format('2. LEDC fade down to duty = 0~n')
    Enum.each(ledc_channel, fn channel_config -&gt; do_stage_2(channel_config) end)
    Process.sleep(@test_fade_time)

    loop(ledc_channel)
  end

  defp do_stage_1(channel_config) do
    speed_mode = :proplists.get_value(:speed_mode, channel_config)
    channel = :proplists.get_value(:channel, channel_config)
    :ok = LEDC.set_fade_with_time(speed_mode, channel, @test_duty, @test_fade_time)
    :ok = LEDC.fade_start(speed_mode, channel, LEDC.fade_no_wait())
  end

  defp do_stage_2(channel_config) do
    speed_mode = :proplists.get_value(:speed_mode, channel_config)
    channel = :proplists.get_value(:channel, channel_config)
    :ok = LEDC.set_fade_with_time(speed_mode, channel, 0, @test_fade_time)
    :ok = LEDC.fade_start(speed_mode, channel, LEDC.fade_no_wait())
  end

  defp read_button(pin) do
    result = GPIO.digital_read(pin)
    :io.format('Result = ~p~n', [result])
    case result do
      :low -&gt; :pressed
      :high -&gt; :released
    end
  end

  defp wait_for_release(pin) do
    Process.sleep(50)

    if read_button(pin) == :pressed do
      wait_for_release(pin)
    else
      :ok
    end
  end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pantalla-oled"><a class="anchor" href="#pantalla-oled"></a>Pantalla OLED</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La pantalla OLED SSD1306 utiliza el protocolo de comunicación I2C para conectarse a la ESP32. Para la transmisión de datos, el pin SDA del display se conecta al pin de datos I2C de la ESP32 (generalmente GPIO21), y el pin SCL del display al pin de reloj I2C de la ESP32 (comúnmente GPIO22).</p>
</div>
<div class="paragraph">
<p>Requiere de un driver adicional: <a href="https://github.com/atomvm/atomgl" class="bare">https://github.com/atomvm/atomgl</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/components/ssd.jpg" alt="ssd">
</div>
<div class="title">Figure 10. Pantalla SSD1306</div>
</div>
<div class="sect2">
<h3 id="guía-de-conexiones-10"><a class="anchor" href="#guía-de-conexiones-10"></a>Guía de Conexiones</h3>
<div class="paragraph">
<p>Para conectar una Pantalla OLED (SSD1306 I2C) a la ESP32:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Pines de la Pantalla OLED</strong>:</p>
</li>
<li>
<p><code>VCC</code>: Alimentación</p>
</li>
<li>
<p><code>GND</code>: Tierra</p>
</li>
<li>
<p><code>SCL</code>: Línea de reloj I2C</p>
</li>
<li>
<p><code>SDA</code>: Línea de datos I2C</p>
</li>
<li>
<p><strong>Conexión a la ESP32</strong>:</p>
</li>
<li>
<p><code>VCC</code> (OLED) &#8594; Pin <code>3V3</code> de la ESP32</p>
</li>
<li>
<p><code>GND</code> (OLED) &#8594; Pin <code>GND</code> de la ESP32</p>
</li>
<li>
<p><code>SCL</code> (OLED) &#8594; Pin <code>GPIO22</code> de la ESP32 (Pin SCL I2C por defecto)</p>
</li>
<li>
<p><code>SDA</code> (OLED) &#8594; Pin <code>GPIO21</code> de la ESP32 (Pin SDA I2C por defecto)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="código-de-ejemplo-9"><a class="anchor" href="#código-de-ejemplo-9"></a>Código de Ejemplo</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule SsdTest do
  @sda_pin 21
  @scl_pin 22

  def start do
    i2c_opts = [
      sda: @sda_pin,
      scl: @scl_pin,
      clock_speed_hz: 40000,
      peripheral: "i2c0"
    ]

    i2c_host = :i2c.open(i2c_opts)

    display_opts = [
      width: 128,
      height: 64,
      compatible: "solomon-systech,ssd1306",
      i2c_host: i2c_host,
      reset: 18
    ]

    display = :erlang.open_port({:spawn, "display"}, display_opts)

    {:ok, pid} =
      HelloScene.start_link([],
        display_server: {:port, display}
      )

    Process.sleep(:infinity)
  end
end

defmodule HelloScene do
  def start_link(args, opts) do
    :avm_scene.start_link(__MODULE__, args, opts)
  end

  def init(_args) do
    :erlang.send_after(100, self(), :update_display)
    {:ok, %{width: 320, height: 240}}
  end

  def handle_info(:update_display, %{width: width, height: height} = state) do
    items = [
      {:text, 10, 20, :default16px, 0x000000, 0xFFFFFF, "Hello, World!"},
      {:rect, 0, 0, width, height, 0xFFFFFF}
    ]

    {:noreply, state, [{:push, items}]}
  end
end</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">mix.exs</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">  defp deps do
    [
      {:avm_scene, git: "https://github.com/atomvm/avm_scene/"},
      {:exatomvm, git: "https://github.com/atomvm/ExAtomVM/"}
    ]
  end</code></pre>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="devenv.html">Entorno de Desarrollo</a></span>
  <span class="next"><a href="remote.html">Conexión Remota</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Creado por miembros de <a href="https://elixircl.github.io">Elixir Chile</a></p>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
<script type="text/javascript">
  // Add custom scripts
</script>
<script src="../_/js/vendor/lunr.js"></script>
<script src="../_/js/search-ui.js" id="search-ui-script" data-site-root-path=".." data-snippet-length="100" data-stylesheet="../_/css/search.css"></script>
<script async src="../search-index.js"></script>
  </body>
</html>
