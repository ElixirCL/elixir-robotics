<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Proyecto: Videojuego Arcade :: Electrónica, Robótica e IOT con Elixir</title>
    <link rel="canonical" href="https://elixircl.github.io/elixir-robotics/atomvm/arcade.html">
    <link rel="prev" href="colosseo.html">
    <link rel="next" href="tagboard.html">
    <meta name="generator" content="Antora 3.1.14">
    <link rel="stylesheet" href="../_/css/site.css">
    <link rel="stylesheet" href="../_/js/vendor/styles/monokai.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://elixircl.github.io/elixir-robotics">Electrónica, Robótica e IOT con Elixir</a>
      <div class="navbar-item search hide-for-print">
        <div id="search-field" class="field">
          <input id="search-input" type="text" placeholder="Buscar en documentos">
        </div>
      </div>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <!--
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
    -->
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ROOT" data-version="">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../index.html">Electrónica, Robótica e IOT con Elixir</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Fundamentos e Historia</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/history.html">Historia de la Robótica y Automatización</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/introduction.html">Introducción a la Electrónica</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/electricity.html">Fundamentos de Electricidad</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../fundamentals/programming.html">Lenguajes de Programación</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">IC y Controladores</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/ic555.html">IC555</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/pic16f877a.html">PIC16F877a</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/basicstamp.html">Parallax Basic Stamp</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/arduino.html">Arduino</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/raspberry.html">Raspberry Pi</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/esp32.html">ESP32</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/stm32.html">STM32</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/jetson.html">Nvidia Jetson &amp; AMD Kria</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../controllers/fpga.html">FPGA</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Protocolos de Comunicación</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../communication/iot.html">IOT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Herramientas</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/platformio.html">PlatformIO IDE</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/home-assistant.html">Home Assistant</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/dashboards.html">Dashboards</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/cad.html">Herramientas de Computer Asisted Design (CAD)</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/stores.html">Tiendas</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../tools/grafana_home-assistant.html">Grafana + Home Assistant</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">AtomVM</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="atomvm.html">AtomVM</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="popcorn.html">Elixir PopCorn</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="devenv.html">Entorno de Desarrollo</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="components.html">Componentes Electrónicos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="remote.html">Conexión Remota</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="colosseo.html">Coliseo Atómico</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="arcade.html">Proyecto: Videojuego Arcade</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="tagboard.html">Proyecto: Tagboard</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Hardware Avanzado</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/nerves.html">Nerves</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/circuits.html">Elixir Circuits</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/soleil.html">Soleil</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/beambots.html">Beam Bots</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../advanced/grisp.html">GRiSP</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Energía Solar</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../solar/solar.html">Energía Solar</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Electrónica, Robótica e IOT con Elixir</span>
    <span class="version"></span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <div class="title"><a href="../index.html">Electrónica, Robótica e IOT con Elixir</a></div>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Electrónica, Robótica e IOT con Elixir</a></li>
    <li>AtomVM</li>
    <li><a href="arcade.html">Proyecto: Videojuego Arcade</a></li>
  </ul>
</nav>
<div class="edit-this-page"><a href="file:///antora/./modules/atomvm/pages/arcade.adoc">Editar esta página</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contenidos" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Proyecto: Videojuego Arcade</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Este proyecto tiene por objetivo la creación de un arcade clásico
de los años 70 y principios de los 80 donde se utilizaban
displays, pontenciómetros e interrupters en el gabinete para complementar el videojuego.</p>
</div>
<div class="paragraph">
<p>En específico se utilizará el juego Speed Race (Taito, 1974) o Monaco GP (Sega, 1979)
como principal inspiración.</p>
</div>
<iframe width="100%" height="515" src="https://www.youtube.com/embed/5jc9_xrD2_M?si=FiIRvA4kTtonmArJ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<iframe width="100%" height="515" src="https://www.youtube.com/embed/-Sh7S8Ub5AQ?si=UE4aqX_wABc-Mp24" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<iframe width="100%" height="515" src="https://www.youtube.com/embed/n7Vl6g0RiHI?si=iHBHP6lmPClUBPbZ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>
</div>
<div class="sect1">
<h2 id="componentes-del-proyecto"><a class="anchor" href="#componentes-del-proyecto"></a>Componentes del Proyecto</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El proyecto consiste en usar los componentes de hardware que estarán conectados
via GPIO o Conexión Serial (ESP32) a una Raspberry PI o Computador con un videojuego creado en PICO-8 (<a href="https://pico-8.fandom.com/wiki/GPIO" class="bare">https://pico-8.fandom.com/wiki/GPIO</a>) o TIC-80 (<a href="https://tic80.com/play" class="bare">https://tic80.com/play</a>).
Se debe crear o seleccionar un juego y habilitar controlarlo con los sensores y gatillar eventos
como leds u otros movimientos de los actuadores.</p>
</div>
<div class="paragraph">
<p>Para este ejemplo se utilizará un potenciómetro y un led rgb para enviar eventos
al juego y mostrar un color azul si se llega a un puntaje específico y
un color rojo si se pierde una vida.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Componentes Electrónicos Necesarios</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Componente</th>
<th class="tableblock halign-left valign-top">Cantidad</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Potenciometro</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simula un manubrio de carreras. <a href="https://afel.cl/products/potenciometro-500k-ohm" class="bare">https://afel.cl/products/potenciometro-500k-ohm</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Led RGB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Muestra hitos de puntaje o estado de Game Over. <a href="https://afel.cl/products/diodo-led-rgb-5mm" class="bare">https://afel.cl/products/diodo-led-rgb-5mm</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Botones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simula teclas "Z" y "X" en juegos que lo requieran. <a href="https://afel.cl/products/boton-tactil-tapa-12x12x7-3-interruptor" class="bare">https://afel.cl/products/boton-tactil-tapa-12x12x7-3-interruptor</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resistencias</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Necesarias para proteger al LED.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>También se puede obtar por un Kit de componentes básicos como</p>
</div>
<div class="paragraph">
<p><a href="https://mcielectronics.cl/shop/product/kit-basico-de-inicio-de-componentes-electronicos-para-esp32-esp-32s/" class="bare">https://mcielectronics.cl/shop/product/kit-basico-de-inicio-de-componentes-electronicos-para-esp32-esp-32s/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="tic-80"><a class="anchor" href="#tic-80"></a>TIC-80</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TIC-80 si bien tiene mayor flexibilidad de que PICO-8 al ser de código libre,
no tiene funcionalidades para leer o escribir datos en serial o GPIO. Por lo que
la opción es lo siguiente:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Se crea un projecto en ESP32 que lea todos los sensores</p>
</li>
<li>
<p>Se comunica via serial a un demonio creado en un lenguaje de programación como Go o Python</p>
</li>
<li>
<p>Este demonio gatilla eventos de teclado para simular presión de botones dentro de TIC-80.</p>
</li>
<li>
<p>TIC-80 escribe en un archivo de texto serial el Score actual.</p>
</li>
<li>
<p>El demonio lee el archivo y lo parsea para mostrar los datos en el display segmentado.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Para poder ejecutar el juego y obtener los registros del log se puede ejecutar el siguiente comando:</p>
</div>
<div class="listingblock">
<div class="title">Comando para obtener los logs de un juego en TIC80</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./tic80 esp32.tic &gt; out.log &amp;</code></pre>
</div>
</div>
<div class="paragraph">
<p>También se puede redireccionar directamente el stdout al daemon que usaremos
como puente entre la ESP32 y TIC-80.</p>
</div>
<div class="listingblock">
<div class="title">Redireccionar stdout via pipes</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">$ ./tic80 esp32.tic | daemon</code></pre>
</div>
</div>
<div class="paragraph">
<p>El siguiente código demuestra como utilizar la función <code>trace()</code>
para enviar información a stdout desde TIC-80.</p>
</div>
<div class="listingblock">
<div class="title">Primero Creamos un cartucho de Lua</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">&gt; new lua</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Demostración de Uso de trace()</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-lua hljs" data-lang="lua">-- title:   esp32 test cart
-- author:  ninjas.cl
-- desc:    A test cart for input/output to esp32
-- site:    elixircl.github.io/elixir-robotics
-- license: BSD License
-- version: 0.1
-- script:  lua

t=0
x=96
y=24

function TIC()
  cls(13)

  if btn(0) then y=y-1 end
	if btn(1) then y=y+1 end
	if btn(2) then x=x-1 end
	if btn(3) then x=x+1 end

	if btn(4) then
	  print("Player 1: A", 90, 100)
	end

	if btn(5) then
	  print("Player 1: B", 90, 100)
	end

	if btn(6) then
	  print("Player1: X", 90, 100)
	end

	if btn(7) then
	  print("Player1: Y", 90, 100)
	end

	spr(1+t%60//30*2,x,y,14,3,0,0,2,2)
	print("ESP32 TEST",84,84)
	t=t+1

	if t &gt; 999 then
	 t = 0
	end

	print(t, 0, 0)

	trace("stdout=time:"..t)
end

-- &lt;TILES&gt;
-- 001:eccccccccc888888caaaaaaaca888888cacccccccacc0ccccacc0ccccacc0ccc
-- 002:ccccceee8888cceeaaaa0cee888a0ceeccca0ccc0cca0c0c0cca0c0c0cca0c0c
-- 003:eccccccccc888888caaaaaaaca888888cacccccccacccccccacc0ccccacc0ccc
-- 004:ccccceee8888cceeaaaa0cee888a0ceeccca0cccccca0c0c0cca0c0c0cca0c0c
-- 017:cacccccccaaaaaaacaaacaaacaaaaccccaaaaaaac8888888cc000cccecccccec
-- 018:ccca00ccaaaa0ccecaaa0ceeaaaa0ceeaaaa0cee8888ccee000cceeecccceeee
-- 019:cacccccccaaaaaaacaaacaaacaaaaccccaaaaaaac8888888cc000cccecccccec
-- 020:ccca00ccaaaa0ccecaaa0ceeaaaa0ceeaaaa0cee8888ccee000cceeecccceeee
-- &lt;/TILES&gt;

-- &lt;WAVES&gt;
-- 000:00000000ffffffff00000000ffffffff
-- 001:0123456789abcdeffedcba9876543210
-- 002:0123456789abcdef0123456789abcdef
-- &lt;/WAVES&gt;

-- &lt;SFX&gt;
-- 000:000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000304000000000
-- &lt;/SFX&gt;

-- &lt;PALETTE&gt;
-- 000:1a1c2c5d275db13e53ef7d57ffcd75a7f07038b76425717929366f3b5dc941a6f673eff7f4f4f494b0c2566c86333c57
-- &lt;/PALETTE&gt;

-- &lt;TRACKS&gt;
-- 000:100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
-- &lt;/TRACKS&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el resto del proyecto, se utilizará el juego <a href="https://tic80.com/play?cart=2178">CAR ADVENTURE</a> con una modificación en el código para enviar eventos a través del standard output.</p>
</div>
<div class="sect2">
<h3 id="modificación-del-codigo-fuente"><a class="anchor" href="#modificación-del-codigo-fuente"></a>Modificación del codigo fuente</h3>
<div class="paragraph">
<p>El código fuente de un juego se puede acceder después de ejecutarlo a través de TIC-80, al presionar la tecla ESC. En el editor de código ahora abierto, usa la función de búsqueda (CTRL+F) para modificar las siguientes secciones:</p>
</div>
<div class="listingblock">
<div class="title">Evento de puntaje (cerca de línea 175)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-lua hljs" data-lang="lua">  ...
	print("Score:"..math.ceil(player.score),5,128,COLRscore_2,true)
	print("Score:"..math.ceil(player.score),4,127,COLRscore_1,true)
	--Score


  -- nuevo
	if player.score % 2500 &lt;= 15	then
		trace("event:score_milestone")
	end

  ...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Evento de explosión del auto (cerca de línea 232)</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-lua hljs" data-lang="lua">...

if player.IsCracked == true then
	PlayExplode()--Explosion!!!
	trace("event:explode") -- nueva linea
		if Exp_stop == false then
		sfx(63,"C-4",30,3,15,7)--...And sound
		Exp_stop = true
		end
	end

...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Luego de realizar las modificaciones, la nueva versión se puede guardar presionando CTRL+S.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="esquemático"><a class="anchor" href="#esquemático"></a>Esquemático</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="_images/arcade/esquematico.png" alt="esquematico">
</div>
<div class="title">Figure 1. Esquema de Conexiones</div>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/arcade/resistencia.png" alt="https://resistorcolorcode.in/">
</div>
<div class="title">Figure 2. Resistencia 220 Ohm</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Tabla de conexiones</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pin ESP32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Componente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Función</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3V3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Riel de alimentación de la Protoboard (positivo)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alimentación general para componentes (Potenciómetro, Botones)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Riel de tierra de la Protoboard (negativo)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tierra general para componentes (Potenciómetro, Botones, LED RGB)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Potenciómetro (SIG)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entrada analógica para simular el manubrio de carreras</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">26</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Botón 1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entrada digital</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">25</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Botón 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entrada digital</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resistor 220 Ohm (a LED RGB Rojo)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salida PWM para controlar el color Rojo del LED RGB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">21</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resistor 220 Ohm (a LED RGB Verde)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salida PWM para controlar el color Verde del LED RGB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">23</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resistor 220 Ohm (a LED RGB Azul)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Salida PWM para controlar el color Azul del LED RGB</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="daemon"><a class="anchor" href="#daemon"></a>Daemon</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El Daemon es el encargado de comunicar el ESP32 con TIC-80. Este se ejecuta en el mismo computador
al cual el ESP32 se conecta por USB y ejecuta el TIC-80. Este puede ser programado en Go o Python
y debe comunicarse via serial con el ESP32 y leer el <code>stdout</code> generado por TIC-80.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Biblioteca de Keyboard para Python: <a href="https://github.com/boppreh/keyboard" class="bare">https://github.com/boppreh/keyboard</a></p>
</li>
<li>
<p>Biblioteca de Comunicación Serial para Python: <a href="https://pyserial.readthedocs.io/en/latest/index.html" class="bare">https://pyserial.readthedocs.io/en/latest/index.html</a></p>
</li>
<li>
<p>Biblioteca de Keyboard para Go: <a href="https://github.com/micmonay/keybd_event" class="bare">https://github.com/micmonay/keybd_event</a></p>
</li>
<li>
<p>Biblioteca de Comunicación Serial para Go: <a href="https://github.com/bugst/go-serial" class="bare">https://github.com/bugst/go-serial</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="ejemplo-de-daemon-en-go"><a class="anchor" href="#ejemplo-de-daemon-en-go"></a>Ejemplo de Daemon en Go</h3>
<div class="paragraph">
<p>Este ejemplo de Daemon en Go muestra cómo leer la entrada serial del ESP32,
simular eventos de teclado para TIC-80, y cómo procesar comandos que representarían
eventos del juego para enviar de vuelta al ESP32 (en este caso, para controlar el LED RGB).</p>
</div>
<div class="listingblock">
<div class="title">main.go</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go">package main

import (
	"bufio"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/micmonay/keybd_event"
	"go.bug.st/serial"
)

type KeyAction struct {
	Key      int
	Duration time.Duration // 0 = tap, &gt;0 = hold for this duration
}

type State struct {
	prevPotValue  int
	prevPotTime   time.Time
	keyActionChan chan KeyAction
}

var appLogger = log.New(os.Stdout, "[APP] ", log.LstdFlags|log.Lshortfile)

func main() {
	portName := "/dev/ttyUSB0"
	baudRate := 115200

	if len(os.Args) &gt; 1 {
		portName = os.Args[1]
	}

	appLogger.Printf("Attempting to open serial port: %s at %d baud...\n", portName, baudRate)

	mode := &amp;serial.Mode{
		BaudRate: baudRate,
	}

	port, err := serial.Open(portName, mode)
	if err != nil {
		appLogger.Fatalf("Failed to open serial port %s: %v\n", portName, err)
	}
	defer func() {
		appLogger.Println("Closing serial port...")
		if err := port.Close(); err != nil {
			appLogger.Printf("Error closing serial port: %v\n", err)
		}
	}()

	appLogger.Printf("Successfully opened serial port %s. Starting goroutines...\n", portName)

	keyActionChan := make(chan KeyAction, 10)
	serialWriteChan := make(chan []byte, 10)
	serialReadLinesChan := make(chan string, 100)

	state := State{
		prevPotValue:  -1,
		prevPotTime:   time.Now(),
		keyActionChan: keyActionChan,
	}

	go keyboardWorker(keyActionChan)

	go serialReaderGoroutine(port, serialReadLinesChan)

	go serialWriterGoroutine(port, serialWriteChan)

	go stdinProcessorGoroutine(&amp;state, serialWriteChan)

	go func() {
		var button1Pressed bool
		var button2Pressed bool

		for line := range serialReadLinesChan {
			appLogger.Printf("[Serial Data] Received: %s\n", line)
			action, newButton1Pressed, newButton2Pressed := getSerialKeyAction(&amp;state, line, button1Pressed, button2Pressed)
			button1Pressed = newButton1Pressed
			button2Pressed = newButton2Pressed

			if action.Key != 0 {
				select {
				case state.keyActionChan &lt;- action:
				default:
					appLogger.Printf("Warning: keyActionChan full, dropping action: %+v", action)
				}
			}
		}
		appLogger.Println("[Serial Processor] Exiting.")
	}()

	select {}
}

func serialReaderGoroutine(port serial.Port, outputChan chan&lt;- string) {
	appLogger.Println("[Serial Reader] Starting to read from serial port...")
	reader := bufio.NewReader(port)
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			appLogger.Printf("[Serial Reader] Error reading from serial port: %v\n", err)
			if err == io.EOF || strings.Contains(err.Error(), "device disconnected") || strings.Contains(err.Error(), "no such file") {
				appLogger.Println("[Serial Reader] Device likely disconnected. Pausing for 5s before retrying read.")
				time.Sleep(5 * time.Second)
			} else {
				time.Sleep(100 * time.Millisecond)
			}
			continue
		}

		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}
		outputChan &lt;- line
	}
}

func serialWriterGoroutine(port serial.Port, inputChan &lt;-chan []byte) {
	appLogger.Println("[Serial Writer] Starting to write to serial port...")
	for data := range inputChan {
		n, err := port.Write(data)
		if err != nil {
			appLogger.Printf("[Serial Writer] Error writing %q to serial: %v\n", data, err)
		} else {
			appLogger.Printf("[Serial Writer] Wrote %d bytes to serial: %q\n", n, data)
		}
	}
	appLogger.Println("[Serial Writer] Exiting.")
}

func stdinProcessorGoroutine(state *State, serialWriteChan chan&lt;- []byte) {
	appLogger.Println("[Stdin Processor] Reading from stdin. Type 'serial:&lt;message&gt;' to send to serial.")
	appLogger.Println("[Stdin Processor] Example: serial:AT\\r\\n")
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		line := scanner.Text()
		appLogger.Printf("[Stdin Processor] Received from stdin: %q\n", line)
		processStdinCommand(state, line, serialWriteChan)
	}
	if err := scanner.Err(); err != nil {
		appLogger.Printf("[Stdin Processor] Error reading stdin: %v\n", err)
	}
	appLogger.Println("[Stdin Processor] Stdin closed or error. Exiting.")
}

func processStdinCommand(state *State, input string, serialWriteChan chan&lt;- []byte) {
	if after, ok := strings.CutPrefix(input, "&gt;event:"); ok {
		switch after {
		case "explode":
			msgBytes := []byte("red")
			select {
			case serialWriteChan &lt;- msgBytes:
				appLogger.Printf("[Stdin Cmd] Queued message for serial: %q\n", msgBytes)
			default:
				appLogger.Println("[Stdin Cmd] Serial write channel full, dropping message.")
			}
		case "score_milestone":
			msgBytes := []byte("blue")
			select {
			case serialWriteChan &lt;- msgBytes:
				appLogger.Printf("[Stdin Cmd] Queued message for serial: %q\n", msgBytes)
			default:
				appLogger.Println("[Stdin Cmd] Serial write channel full, dropping message.")
			}
		}
	} else {
		appLogger.Printf("[Stdin Cmd] Unrecognized stdin command: %q\n", input)
	}
}

func getSerialKeyAction(state *State, input string, button1Pressed bool, button2Pressed bool) (KeyAction, bool, bool) {
	if strings.Contains(input, "Button 1:") {
		if strings.Contains(input, "pressed") &amp;&amp; !button1Pressed {
			appLogger.Println("[Serial Data] Button 1 pressed.")
			return KeyAction{Key: keybd_event.VK_X, Duration: 0}, true, button2Pressed
		} else if strings.Contains(input, "released") {
			appLogger.Println("[Serial Data] Button 1 released.")
			return KeyAction{}, false, button2Pressed
		}
		return KeyAction{}, button1Pressed, button2Pressed
	}

	if strings.Contains(input, "Button 2:") {
		if strings.Contains(input, "pressed") &amp;&amp; !button2Pressed {
			appLogger.Println("[Serial Data] Button 2 pressed.")
			return KeyAction{Key: keybd_event.VK_Z, Duration: 0}, button1Pressed, true
		} else if strings.Contains(input, "released") {
			appLogger.Println("[Serial Data] Button 2 released.")
			return KeyAction{}, button1Pressed, false
		}
		return KeyAction{}, button1Pressed, button2Pressed
	}

	if strings.HasPrefix(input, "Potentiometer:") {
		parts := strings.Split(input, " ")
		if len(parts) &lt; 2 {
			return KeyAction{}, button1Pressed, button2Pressed
		}

		rawStr := strings.TrimPrefix(parts[1], "raw=")
		rawVal, err := strconv.Atoi(rawStr)
		if err != nil {
			return KeyAction{}, button1Pressed, button2Pressed
		}

		if state.prevPotValue == -1 {
			state.prevPotValue = rawVal
			state.prevPotTime = time.Now()
			return KeyAction{}, button1Pressed, button2Pressed
		}

		diff := rawVal - state.prevPotValue

		now := time.Now()
		if now.Sub(state.prevPotTime) &lt;= 50*time.Millisecond {
			return KeyAction{}, button1Pressed, button2Pressed
		}

		var key int
		absDiff := diff
		if diff &gt; 0 {
			key = keybd_event.VK_RIGHT
		} else if diff &lt; 0 {
			key = keybd_event.VK_LEFT
			absDiff = -diff
		} else {
			return KeyAction{}, button1Pressed, button2Pressed
		}

		if absDiff &lt; 50 {
			return KeyAction{}, button1Pressed, button2Pressed
		}

		duration := calculateDuration(absDiff)
		appLogger.Printf("[Serial Data] Potentiometer changed by %d. Sending key %v for %v.\n", diff, key, duration)

		state.prevPotValue = rawVal
		state.prevPotTime = now

		return KeyAction{Key: key, Duration: duration}, button1Pressed, button2Pressed
	}

	return KeyAction{}, button1Pressed, button2Pressed
}

func keyboardWorker(ch &lt;-chan KeyAction) {
	appLogger.Println("[Keyboard Worker] Starting...")
	kb, err := keybd_event.NewKeyBonding()
	if err != nil {
		appLogger.Fatalf("Fatal: failed to create KeyBonding in worker: %v", err)
		return
	}

	for action := range ch {
		appLogger.Printf("[Keyboard Worker] Performing action: %+v\n", action)
		if action.Duration == 0 {
			kb.SetKeys(action.Key)
			kb.Launching()
		} else {
			kb.SetKeys(action.Key)
			kb.Press()
			time.Sleep(action.Duration)
			kb.Release()
		}
	}
	appLogger.Println("[Keyboard Worker] Exiting.")
}

func calculateDuration(diff int) time.Duration {
	switch {
	case diff &gt;= 1000:
		return 500 * time.Millisecond
	case diff &gt;= 500:
		return 300 * time.Millisecond
	case diff &gt;= 250:
		return 200 * time.Millisecond
	case diff &gt;= 100:
		return 100 * time.Millisecond
	case diff &gt;= 50:
		return 50 * time.Millisecond
	default:
		return 0
	}
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="programa-para-esp32-elixiratomvm"><a class="anchor" href="#programa-para-esp32-elixiratomvm"></a>Programa para ESP32 (Elixir/AtomVM)</h3>
<div class="paragraph">
<p>Este programa está diseñado para ejecutarse en un ESP32 utilizando AtomVM.
Su función principal es leer el estado de los sensores de entrada (botones y potenciómetro)
y enviar esta información por el puerto serial al Daemon en el computador.
Adicionalmente, escucha el puerto serial para recibir comandos del Daemon
(basados en eventos del juego TIC-80) y controlar el LED RGB.</p>
</div>
<div class="listingblock">
<div class="title">AtomVM Elixir</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-elixir hljs" data-lang="elixir">defmodule Tic80 do
  @led_duty 1000
  @rgb_duty 4000

  @high_speed_timer 0

  @led_r 22
  @led_g 21
  @led_b 23

  @button_1_pin 26
  @button_2_pin 25
  @potentiometer_pin 32

  def start do
    rgb_channels = setup_leds()
    setup_input(rgb_channels)

    LEDC.set_duty(LEDC.high_speed_mode(), 0, @led_duty)
    LEDC.update_duty(LEDC.high_speed_mode(), 0)

    spawn(fn -&gt; button_monitor(@button_1_pin, "Button 1") end)
    spawn(fn -&gt; button_monitor(@button_2_pin, "Button 2") end)
    spawn(fn -&gt; potentiometer_monitor(@potentiometer_pin) end)

    Process.sleep(:infinity)
  end

  defp setup_leds() do
    ledc_hs_timer = [
      {:duty_resolution, 13},
      {:freq_hz, 5000},
      {:speed_mode, LEDC.high_speed_mode()},
      {:timer_num, @high_speed_timer}
    ]

    :ok = LEDC.timer_config(ledc_hs_timer)

    ledc_channel = [
      [
        {:channel, 1},
        {:duty, 0},
        {:gpio_num, @led_r},
        {:speed_mode, LEDC.high_speed_mode()},
        {:hpoint, 0},
        {:timer_sel, @high_speed_timer}
      ],
      [
        {:channel, 2},
        {:duty, 0},
        {:gpio_num, @led_g},
        {:speed_mode, LEDC.high_speed_mode()},
        {:hpoint, 0},
        {:timer_sel, @high_speed_timer}
      ],
      [
        {:channel, 3},
        {:duty, 0},
        {:gpio_num, @led_b},
        {:speed_mode, LEDC.high_speed_mode()},
        {:hpoint, 0},
        {:timer_sel, @high_speed_timer}
      ]
    ]

    Enum.each(ledc_channel, fn channel_config -&gt; :ok = LEDC.channel_config(channel_config) end)
    :ok = LEDC.fade_func_install(0)

    %{
      red: Enum.at(ledc_channel, 0),
      green: Enum.at(ledc_channel, 1),
      blue: Enum.at(ledc_channel, 2)
    }
  end

  defp button_monitor(pin, name) do
    GPIO.set_pin_mode(pin, :input)
    GPIO.set_pin_pull(pin, :up)
    button_loop(pin, name, :released)
  end

  defp button_loop(pin, name, last_state) do
    current_state =
      case GPIO.digital_read(pin) do
        :low -&gt; :pressed
        :high -&gt; :released
      end

    if current_state != last_state do
      :io.format('~s: ~s~n', [name, current_state])
      Process.sleep(50)
      button_loop(pin, name, current_state)
    else
      Process.sleep(100)
      button_loop(pin, name, last_state)
    end
  end

  defp potentiometer_monitor(pin) do
    :ok = :esp_adc.start(pin, bitwidth: :bit_max, atten: :db_12)
    pot_loop(pin, nil, nil)
  end

  defp pot_loop(pin, last_raw, last_mv) do
    case :esp_adc.read(pin, [:raw, :voltage, samples: 48]) do
      {:ok, {raw, mv}} -&gt;
        if last_raw == nil || abs(raw - last_raw) &gt; 50 do
          :io.format('Potentiometer: raw=~p mv=~p~n', [raw, mv])
          Process.sleep(200)
          pot_loop(pin, raw, mv)
        else
          Process.sleep(200)
          pot_loop(pin, last_raw, last_mv)
        end

      error -&gt;
        :io.format('ADC error: ~p~n', [error])
        Process.sleep(500)
        pot_loop(pin, last_raw, last_mv)
    end
  end

  defp setup_input(rgb_channels) do
    uart = :uart.open("UART0", rx: 3, tx: 1, speed: 115_200)
    :io.format('UART0 opened successfully. Sending and receiving on ~p~n', [uart])
    spawn(fn -&gt; loop_read(uart, rgb_channels) end)
  end

  defp loop_read(uart, rgb_channels) do
    data = :uart.read(uart)

    case data do
      '' -&gt;
        Process.sleep(50)

      {:ok, string} -&gt;
        :io.format('Received: ~p~n', [string])

        process_command(string, rgb_channels)
    end

    loop_read(uart, rgb_channels)
  end

  defp process_command(&lt;&lt;"red"&gt;&gt;, %{red: red_channel}) do
    apply_duty(red_channel, @rgb_duty)
    Process.sleep(1000)
    apply_duty(red_channel, 0)
  end

  defp process_command(&lt;&lt;"green"&gt;&gt;, %{green: green_channel}) do
    apply_duty(green_channel, @rgb_duty)
    Process.sleep(1000)
    apply_duty(green_channel, 0)
  end

  defp process_command(&lt;&lt;"blue"&gt;&gt;, %{blue: blue_channel}) do
    apply_duty(blue_channel, @rgb_duty)
    Process.sleep(1000)
    apply_duty(blue_channel, 0)
  end

  defp process_command(_, _), do: :io.format('Invalid input.~n')

  defp apply_duty(channel_config, duty) do
    speed_mode = :proplists.get_value(:speed_mode, channel_config)
    channel = :proplists.get_value(:channel, channel_config)
    :ok = LEDC.set_duty(speed_mode, channel, duty)
    :ok = LEDC.update_duty(speed_mode, channel)
  end
end</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ejecución"><a class="anchor" href="#ejecución"></a>Ejecución</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Luego de modificar el código fuente del juego, crear el proyecto de Go y
flashear el programa al ESP32, el proyecto se puede ejecutar con el comando
<code>tic80 ./car_adventure.tic | sudo go run main.go</code>. Esto conecta el <code>stdout</code> del
juego TIC-80 con el Daemon de Go a través de una pipe.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="flujo-de-datos-y-control"><a class="anchor" href="#flujo-de-datos-y-control"></a>Flujo de Datos y Control</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para entender cómo todos los componentes interactúan, podemos seguir el flujo de
datos y control a través del sistema:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Entrada Física (Hardware - ESP32):</strong></p>
<div class="ulist">
<ul>
<li>
<p>El <strong>Potenciómetro</strong> y los <strong>Botones</strong> son manipulados por el jugador.</p>
</li>
<li>
<p>El <strong>ESP32</strong>, ejecutando el programa Elixir, monitorea constantemente el estado de estos componentes.</p>
</li>
<li>
<p>Lee el valor analógico del potenciómetro a través de un pin.</p>
</li>
<li>
<p>Detecta los cambios de estado (presionado/liberado) de los botones a través de pines GPIO.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Comunicación Serial (ESP32 a Computador):</strong></p>
<div class="ulist">
<ul>
<li>
<p>El programa del ESP32 imprime los valores y estados leídos (ej. <code>Potentiometer: raw=XXXX</code>, <code>Button 1: pressed</code>) a su output serial.</p>
</li>
<li>
<p>Este output serial se envía al computador host a través de la conexión USB (que utiliza un puerto serial, típicamente <code>/dev/ttyUSB0</code> en Linux).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Procesamiento del Daemon (Computador):</strong></p>
<div class="ulist">
<ul>
<li>
<p>El <strong>Daemon Go</strong> se ejecuta en el computador host.</p>
</li>
<li>
<p>La goroutine <code>serialReaderGoroutine</code> del Daemon lee continuamente los datos del puerto serial (provenientes del ESP32).</p>
</li>
<li>
<p>La función <code>getSerialKeyAction</code> del Daemon procesa estas líneas. Por ejemplo, un cambio significativo en el potenciómetro se traduce en una acción de "flecha derecha" o "flecha izquierda", y una pulsación de botón en "tecla X" o "tecla Z".</p>
</li>
<li>
<p>Estas acciones de teclado son enviadas a través del <code>keyActionChan</code> a la goroutine <code>keyboardWorker</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Control del Juego (Daemon a TIC-80):</strong></p>
<div class="ulist">
<ul>
<li>
<p>La goroutine <code>keyboardWorker</code> del Daemon utiliza la biblioteca <code>keybd_event</code> para simular pulsaciones de teclas en el sistema operativo.</p>
</li>
<li>
<p>El juego <strong>TIC-80</strong> (CAR ADVENTURE) está ejecutándose en el mismo computador y recibe estas pulsaciones de teclas como si un jugador estuviera interactuando directamente con el teclado. Esto permite controlar el auto, acelerar, etc.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Eventos del Juego (TIC-80 a Daemon):</strong></p>
<div class="ulist">
<ul>
<li>
<p>Mientras el juego TIC-80 se ejecuta, las modificaciones hechas en su código (<code>trace("event:score_milestone")</code>, <code>trace("event:explode")</code>) envían eventos específicos a su salida estándar (<code>stdout</code>).</p>
</li>
<li>
<p>La goroutine <code>stdinProcessorGoroutine</code> del Daemon (leyendo el <code>stdout</code> del proceso TIC-80) detecta estos eventos.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Retroalimentación al Jugador (Daemon a ESP32 a Hardware):</strong></p>
<div class="ulist">
<ul>
<li>
<p>Cuando el Daemon detecta un evento (como "explode"), la función <code>processStdinCommand</code> envía un comando específico (ej. "red" para explosión, "blue" para hito de score) al <code>serialWriteChan</code>.</p>
</li>
<li>
<p>La goroutine <code>serialWriterGoroutine</code> del Daemon envía estos comandos de vuelta al <strong>ESP32</strong> a través del puerto serial.</p>
</li>
<li>
<p>El programa del ESP32, en su <code>loop_read</code> y <code>process_command</code>, recibe e interpreta estos comandos.</p>
</li>
<li>
<p>Finalmente, la función <code>apply_duty</code> del ESP32 controla el led RGB conectado a sus pines, encendiendo el color correspondiente (rojo para explosión, azul para score milestone) para dar retroalimentación visual al jugador.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="demo"><a class="anchor" href="#demo"></a>Demo</h2>
<div class="sectionbody">
<div class="videoblock">
<div class="content">
<video src="_images/atomvm/tic80.mp4" controls>
Your browser does not support the video tag.
</video>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="código-fuente"><a class="anchor" href="#código-fuente"></a>Código Fuente</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Todo el código fuente puede ser visualizado en:</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/ElixirCL/elixir-robotics/tree/main/modules/atomvm/examples/tic80" class="bare">https://github.com/ElixirCL/elixir-robotics/tree/main/modules/atomvm/examples/tic80</a></p>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="colosseo.html">Coliseo Atómico</a></span>
  <span class="next"><a href="tagboard.html">Proyecto: Tagboard</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Creado por miembros de <a href="https://elixircl.github.io">Elixir Chile</a></p>
</footer>
<script id="site-script" src="../_/js/site.js" data-ui-root-path="../_"></script>
<script async src="../_/js/vendor/highlight.js"></script>
<script type="text/javascript">
  // Add custom scripts
</script>
<script src="../_/js/vendor/lunr.js"></script>
<script src="../_/js/search-ui.js" id="search-ui-script" data-site-root-path=".." data-snippet-length="100" data-stylesheet="../_/css/search.css"></script>
<script async src="../search-index.js"></script>
  </body>
</html>
