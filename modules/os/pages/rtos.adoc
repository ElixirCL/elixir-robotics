= Sistemas Operativos en Tiempo Real

Un sistema operativo en tiempo real (RTOS, Real-Time Operating System) 
es un tipo de sistema operativo diseñado para responder a eventos y ejecutar 
tareas dentro de plazos estrictos y deterministas. La clave no es solo ejecutar 
tareas correctamente, sino garantizar que se ejecuten a tiempo.

En contraste, un sistema operativo tradicional (como Windows, Linux de escritorio o macOS) 
se centra en rendimiento y multitarea general, pero no garantiza 
tiempos de respuesta deterministas.

Un RTOS garantiza "hacer lo correcto y a tiempo", 
mientras que un OS tradicional garantiza "hacer lo correcto eventualmente".

*Ejemplo*:

- RTOS: control de un motor, parpadeo de un LED crítico, sistema de frenos ABS en un automóvil.
- OS tradicional: abrir un navegador, reproducir música, ejecutar software de oficina.

.Comparación entre RTOS y OS
[cols="1,1,1", options="header"]
|===
| Característica               | RTOS                                | Sistema Operativo Tradicional

| Objetivo principal
| Cumplimiento de tiempos estrictos
| Rendimiento general y multitarea

| Determinismo
| Garantizado
| No determinista

| Planificador (scheduler)
| Prioridad estricta, preemptivo
| Basado en tiempo compartido / fairness

| Uso de recursos
| Optimizado, bajo consumo
| Flexible, más pesado

| Latencia de interrupción
| Muy baja (microsegundos a milisegundos)
| Variable, puede ser alta

| Ejemplos típicos
| FreeRTOS, Zephyr, ThreadX, VxWorks
| Windows, Linux, macOS

| Aplicaciones
| Automoción, robótica, IoT, control industrial
| PCs, servidores, smartphones
|===


== FreeRTOS

FreeRTOS es un kernel de sistema operativo en tiempo real (RTOS) 
diseñado específicamente para sistemas incrustado. Se ha adaptado a más de 
40 arquitecturas de microcontroladores (incluyendo el ESP32) y se distribuye bajo licencia MIT.

Está diseñado para ser compacto y sencillo, y está escrito principalmente en C. 
FreeRTOS proporciona mecanismos para la gestión de múltiples hilos (tareas), mutexes, 
semáforos y temporizadores, manteniendo un bajo consumo de memoria y 
tiempos de ejecución rápidos.

*Este es el framework usado por AtomVM*

.Ejemplo de LED con FreeRTOS
[source, c]
----
#include "FreeRTOS.h"
#include "task.h"

/* Funciones dependientes del hardware */
void LED_Init(void);
void LED_Toggle(void);

/* Tarea de parpadeo */
void vLedTask(void *pvParameters)
{
    while (1)
    {
        LED_Toggle();
        vTaskDelay(pdMS_TO_TICKS(500)); // 500 ms
    }
}

int main(void)
{
    /* Inicialización del hardware */
    LED_Init();

    /* Crear la tarea */
    xTaskCreate(
        vLedTask,          // Función de la tarea
        "LED Task",        // Nombre
        128,               // Tamaño del stack (words)
        NULL,              // Parámetro
        1,                 // Prioridad
        NULL               // Handle
    );

    /* Iniciar el scheduler */
    vTaskStartScheduler();

    /* Nunca debería llegar aquí */
    while (1) {}
}
----

=== Recursos

- Tutorial en video sobre FreeRTOS: https://www.youtube.com/watch?v=kcsHsoWmbDI
- Documentación ESP-IDF (con FreeRTOS): https://www.espressif.com/en/products/sdks/esp-idf
- Otro tutorial en video sobre FreeRTOS: https://www.youtube.com/watch?v=s5DnmeOwkxo
- Introducción a las tareas en FreeRTOS: https://www.youtube.com/watch?v=F321087yYy4

== Zephyr

Zephyr es un RTOS compacto y escalable que ofrece un mayor control 
sobre el sistema a cambio de una mayor complejidad. Soporta más de 170 
dispositivos y es altamente configurable y modular. Permite desarrollar 
aplicaciones para diversas arquitecturas mediante Device Trees, 
utilizados para describir el hardware y la información de configuración.

El proyecto se beneficia de un ciclo de vida de desarrollo seguro, que 
incluye validación de seguridad, fuzz testing, penetration testing y análisis de código estático.

Es más completo que FreeRTOS y proporciona abstracciones que permiten 
migrar fácilmente el código de una plataforma a otra. Es decir que las aplicaciones 
pueden ser trasladadas entre microcontroladores sin muchos cambios.

.Ejemplo de LED con Zephyr
[source, c]
----
#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/gpio.h>

/* Obtener el LED desde el DeviceTree */
#define LED0_NODE DT_ALIAS(led0)

#if !DT_NODE_HAS_STATUS(LED0_NODE, okay)
#error "No hay un alias led0 en el DeviceTree"
#endif

static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);

int main(void)
{
    int ret;

    if (!device_is_ready(led.port)) {
        return 0;
    }

    ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT_ACTIVE);
    if (ret < 0) {
        return 0;
    }

    while (1) {
        gpio_pin_toggle_dt(&led);
        k_sleep(K_MSEC(500));  // 500 ms
    }
}
----

=== Recursos

- Hola Mundo en Zephyr y ESP32: https://www.youtube.com/watch?v=Z_7y_4O7yTw
- Introducción a Zephyr: https://www.youtube.com/watch?v=jR5E5Kz9A-k
- FreeRTOS vs Zephyr: https://sirinsoftware.com/blog/rtos-wars-freertos-vs-zephyr-a-decision-you-cant-afford-to-get-wrong
- Fundamentos de Zephyr: https://www.youtube.com/watch?v=Qq5qD8OxTtY

== Eclipse Thread-X

Eclipse Thread-X es un RTOS diseñado para sistemas profundamente 
incrustado que utiliza una arquitectura de picokernel. Ofrece 
scheduling avanzado, message passing, gestión de interrupciones y 
servicios de mensajería. Cuenta con certificaciones para aplicaciones 
donde la seguridad es crítica.

Microsoft ha contribuido con la tecnología Azure RTOS a la Eclipse Foundation. 
Con la Eclipse Foundation como su nuevo hogar, Azure RTOS pasa a convertirse en 
Eclipse ThreadX, un conjunto avanzado de herramientas para el desarrollo incrustado 
que incluye un sistema operativo pequeño pero potente, capaz de ofrecer un 
rendimiento fiable y ultrarrápido para dispositivos con recursos limitados.

Eclipse ThreadX ofrece un sistema operativo de código abierto, 
neutral respecto a proveedores y con certificación de seguridad para 
aplicaciones en tiempo real, todo bajo una licencia permisiva. Se distingue como 
el primer y único RTOS que combina de forma única estas características 
para satisfacer una amplia gama de necesidades, beneficiando por igual a 
adoptantes industriales, desarrolladores y usuarios finales.

.Ejemplo de LED con ThreadX
[source, c]
----
#include "tx_api.h"

/* Definiciones */
#define LED_THREAD_STACK_SIZE  1024
#define LED_THREAD_PRIORITY    1

TX_THREAD led_thread;
ULONG led_thread_stack[LED_THREAD_STACK_SIZE / sizeof(ULONG)];

/* Funciones dependientes del hardware */
void LED_Init(void);
void LED_Toggle(void);

/* Thread del LED */
void led_thread_entry(ULONG thread_input)
{
    while (1)
    {
        LED_Toggle();
        tx_thread_sleep(TX_TIMER_TICKS_PER_SECOND / 2); // 500 ms
    }
}

int main(void)
{
    /* Inicialización del hardware */
    LED_Init();

    /* Inicializar ThreadX */
    tx_kernel_enter();
}
----

=== Recursos

- https://threadx.io/

== FreeRTOS vs Zephyr vs ThreadX

La siguiente es una tabla comparativa que ilustra los puntos claves entre las alternativas 
de FreeRTOS, Zephyr y ThreadX.

.Comparación de FreeRTOS, Zephyr y ThreadX
[cols="1,1,1,1", options="header"]
|===
| Característica        | FreeRTOS                          | Zephyr                              | ThreadX

| Tipo de proyecto
| RTOS ligero
| RTOS completo
| RTOS comercial/industrial

| Enfoque principal
| Sistemas incrustados simples
| IoT y sistemas incrustados complejos
| Sistemas incrustados críticos y de alto rendimiento

| Licencia
| MIT
| Apache 2.0
| Comercial con opción de licencia abierta (Eclipse ThreadX)

| Soporte de hardware
| Muy amplio (MCUs)
| Amplio (MCUs y SoCs)
| Amplio (MCUs, SoCs y DSPs)

| Huella de memoria
| Muy baja
| Baja–media
| Baja–media

| Planificación RT
| Sí (preemptiva/cooperativa)
| Sí (configurable)
| Sí (determinista, preemptiva)

| Networking
| Básico (TCP/IP opcional)
| Avanzado (IPv6, BLE, Thread, etc.)
| Opcional, integrable mediante middleware

| Seguridad
| Limitada (depende de librerías)
| Integrada (TLS, secure boot, etc.)
| Integrable, soporte para seguridad en tiempo real

| Ecosistema
| Muy maduro y estable
| En rápido crecimiento
| Estable, usado en industria crítica

| Facilidad de uso
| Alta
| Media
| Media

| Casos de uso típicos
| Sensores, controladores simples
| IoT industrial, dispositivos conectados
| Sistemas incrustados críticos, controladores de dispositivos, robots industriales

| Lenguajes principales
| C
| C, C++
| C

| Ventajas
| Muy ligero, fácil de aprender, gran documentación
| Modular, portable, soporte de IoT, integración con Bluetooth y redes
| Determinista, confiable, ampliamente usado en industria, soporte comercial

| Desventajas
| Limitado para sistemas complejos, no pensado para tiempo real crítico en grandes proyectos
| Curva de aprendizaje más alta, algunas funciones requieren configuración detallada
| Licencia comercial, ecosistema menos abierto que FreeRTOS/Zephyr

| Soporte de tiempo real
| Básico / configurable
| Avanzado, con threads y temporizadores
| Determinista, preemptivo y altamente confiable

| Herramientas de desarrollo
| IDEs estándar (Eclipse, VSCode, PlatformIO), depuradores JTAG/SWD
| West, CMake, Zephyr SDK, IDEs compatibles
| IDEs comerciales (IAR, Keil, STM32CubeIDE con ThreadX), depuración profesional

| Compatibilidad ROS 2 / micro-ROS
| micro-ROS soportado, ideal para MCUs pequeños
| micro-ROS nativo, recomendado para IoT y sensores
| micro-ROS posible vía integración externa, menos documentación que Zephyr
|===


== Otros RTOS

Otras alternativas relevantes.

=== Mbed OS

Mbed OS es un sistema operativo para dispositivos IoT diseñado para un 
desarrollo rápido, basado en microcontroladores Arm Cortex-M de 32 bits y 
mantenido por Arm. La plataforma alcanzará su fin de vida (EOL) en julio de 2026, 
momento a partir del cual dejará de recibir mantenimiento por parte de Arm.

Mbed ha sido un proyecto enormemente popular desde 2009, ayudando a desarrolladores 
profesionales, usuarios del ámbito educativo y a la comunidad maker a crear, 
asegurar, desplegar y actualizar miles de aplicaciones en hardware basado en Arm, 
desarrollado por socios y colaboradores de Mbed.

Un fork comunitario de Mbed OS: Mbed CE, se encuentra en 
desarrollo activo.

==== Recursos 

- https://github.com/mbed-ce

=== RT-Thread

RT-Thread es un RTOS para dispositivos IoT basado en C, 
que cuenta con un amplio ecosistema con soporte para diversos paquetes de 
software, incluyendo componentes externos. Esto se facilita por el diseño 
modular de su kernel, donde los paquetes se compilan por separado del kernel 
y luego se cargan directamente durante la ejecución. Es ideal para aplicaciones 
más complejas y de mayor escala.

==== Recursos

- https://www.arduinolibraries.info/libraries/rt-thread
- https://www.rt-thread.io/

=== VxWorks

VxWorks es un sistema operativo de tiempo real desarrollado como software 
propietario por Wind River Systems. Se puso a la venta la primera versión en 1987.
Es utilizado para sistemas incrustados que habitualmente necesitan una respuesta 
rápida del orden de ms o microsegundos ante interrupciones en su funcionamiento,
una reconocida estabilidad y una seguridad certificada. Forma parte, junto con otros 
sistemas operativos alternativos, de millones de dispositivos electrónicos como 
cajeros automáticos, impresoras, cámaras fotográficas y en sistemas 
críticos de complejos productos aeroespaciales como el avión de pasajeros Boeing 787,
del robot Curiosity de la NASA, o del avión militar Northrop Grumman X-47B, entre otros. 

==== Recursos 

- https://www.windriver.com/products/embedded/vxworks
- https://es.wikipedia.org/wiki/VxWorks

=== Apache Nuttx

Apache Nuttx es un RTOS que se enfoca en el cumplimiento de estándares, 
principalmente POSIX y ANSI C. También adopta funcionalidades de otras 
APIs estándar de Unix y de otros RTOS. Al ofrecer un entorno compatible 
con POSIX, es un sistema RTOS más completo (y por ende, potencialmente más pesado) 
que otras alternativas más minimalistas.

.Parpadear LED en Apache Nuttx
[source, c]
----
#include <nuttx/config.h>
#include <nuttx/init.h>
#include <nuttx/board.h>
#include <stdio.h>
#include <unistd.h>
#include <nuttx/irq.h>
#include <nuttx/gpio/gpio.h>
#include <arch/board/board.h>
#include <pthread.h>

/* Dependiente del hardware */
#define LED_PIN PIN_LED1  // Por ejemplo, en la placa NuttX define PIN_LED1

void *led_task(void *arg)
{
    gpio_direction_out(LED_PIN, 0); // Configurar como salida

    while (1)
    {
        gpio_write(LED_PIN, 1);   // LED encendido
        usleep(500000);           // 500 ms
        gpio_write(LED_PIN, 0);   // LED apagado
        usleep(500000);           // 500 ms
    }

    return NULL;
}

int main(int argc, char *argv[])
{
    pthread_t thread_id;
    pthread_create(&thread_id, NULL, led_task, NULL);

    /* Main puede hacer otras cosas o simplemente dormir */
    while (1)
    {
        sleep(1);
    }

    return 0;
}
----

==== Recursos

- https://nuttx.apache.org/
